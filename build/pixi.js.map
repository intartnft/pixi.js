{"version":3,"file":"pixi.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,EAAE,EAAE,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;;;;;;;;;;;;;;ACjDf;;AAEA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD,SAAS;AACT,8BAA8B,gBAAgB;AAC9C;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,iEAAe;;;;;;;;;;;;;;;AC1Be;AAC9B,YAAY,qDAAS;;AAErB;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA,qDAAqD,YAAY;AACjE,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;;;;;;;;;;;;;;;;ACnHiB;AACF;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAM;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,OAAO,YAAY,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAK;AAChD;AACA,cAAc;AACd,wBAAwB,yDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,YAAY,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAc;AACrC,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;;;;;;;;;;;;;;ACpIf;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf,iEAAe;;;;;;;;;;;;;;;ACRqB;AACpC,YAAY,0DAAS;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;;;;;;;;;;;;;;;ACpCqB;AACpC,YAAY,0DAAS;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;;;;;;UChDf;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;ACNmC;AACE;AACF;AACA;AACA;AACyB;AACR;;AAEpD,cAAc,KAAK,gEAAQ,gEAAO,+DAAO,+DAAO,0EAAkB,oFAAc;;AAEhF,iEAAe,M","sources":["webpack://Pixi/./src/pixi/core/Color.js","webpack://Pixi/./src/pixi/core/Events.js","webpack://Pixi/./src/pixi/core/Scene.js","webpack://Pixi/./src/pixi/core/Shape.js","webpack://Pixi/./src/pixi/core/Utils.js","webpack://Pixi/./src/pixi/effects/PixelColorChange.js","webpack://Pixi/./src/pixi/effects/PixelDistort.js","webpack://Pixi/webpack/bootstrap","webpack://Pixi/webpack/runtime/define property getters","webpack://Pixi/webpack/runtime/hasOwnProperty shorthand","webpack://Pixi/webpack/runtime/make namespace object","webpack://Pixi/./src/pixi/Pixi.js"],"sourcesContent":["class Color {\n    constructor() {\n        this.r = 0\n        this.g = 0\n        this.b = 0\n        this.a = 0\n    }\n\n    static fromHex(hex) {\n        let color = new Color()\n        let rgba = hexToRgbA(hex)\n        color.r = rgba[0]\n        color.g = rgba[1]\n        color.b = rgba[2]\n        color.a = 1\n        return color\n    }\n\n    static fromRGBA(r, g, b, a) {\n        let color = new Color()\n        color.r = r\n        color.g = g\n        color.b = b\n        color.a = a\n        return color\n    }\n\n    format() {\n        return \"rgba(\" + this.r + \",\" + this.g + \",\" + this.b + \",\" + this.a + \")\"\n    }\n\n    clone() {\n        return Color.fromRGBA(this.r, this.g, this.b, this.a)\n    }\n}\n\nconst hexToRgbA = (hex) => {\n    let c;\n    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {\n        c = hex.substring(1).split('');\n        if (c.length == 3) {\n            c = [c[0], c[0], c[1], c[1], c[2], c[2]];\n        }\n        c = '0x' + c.join('');\n        return [(c >> 16) & 255, (c >> 8) & 255, c & 255]\n    }\n    throw new Error('Bad Hex');\n}\n\nexport default Color","const events = {}\n\nclass Events {\n    addListener(event, listener, block) {\n        if (events[event]) {\n            events[event].push({block, listener})\n        }else{\n            events[event] = [{block, listener}]\n        }\n    }\n\n    removeListener(listener) {\n        events = events.filter(event => {\n            return event.listener != listener\n        })\n    }\n\n    fire(event, data) {\n        if (events[event]) {\n            events[event].forEach(event => {\n                event.block(data)\n            });\n        }\n    }\n}\n\nexport default Events","import Utils from \"./Utils.js\"\nconst def = Utils.def\n\nclass Scene {\n    constructor(config) {\n        this.shapes = []\n        this.canvas = config.canvas;\n        this.ctx = config.canvas.getContext('2d');\n        this.scenePixelSize = def(config.scenePixelSize, { width: 50, height: 50 })\n        this.pixelSize = def(config.pixelSize, 10)\n        this.sceneOffset = def(config.sceneOffset, { x: 0, y: 0 })\n        this.pointer = def(config.pointer, { x: 0, y: 0 })\n        this.isStatic = def(config.isStatic, false)\n        this.backgroundColor = def(config.backgroundColor, \"#ffffff\")\n        this.minPixelSize = def(config.minPixelSize, 2)\n    }\n\n    addShape(shape) {\n        this.shapes.push(shape)\n    }\n\n    addShapes(shapes) {\n        shapes.forEach(shape => {\n            this.shapes.push(shape)\n        })\n    }\n\n    centerShape(shape) {\n        shape.x = Math.floor(this.scenePixelSize.width * 0.5)\n        shape.y = Math.floor(this.scenePixelSize.height * 0.5)\n    }\n\n    centerShapes(shapes) {\n        shapes.forEach(shape => {\n            shape.x = Math.floor(this.scenePixelSize.width * 0.5)\n            shape.y = Math.floor(this.scenePixelSize.height * 0.5)\n        })\n    }\n\n    render() {\n        this.clear()\n        this.shapes.forEach(shape => {\n            if (shape.image) {\n                this.drawImage(shape)\n            } else if (shape.pixels) {\n                this.drawPixels(shape)\n            }\n        });\n    }\n\n    clear() {\n        this.ctx.fillStyle = this.backgroundColor\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n    }\n\n    fitInSize(size) {\n        if (size.width > size.height) {\n            this.pixelSize = Math.round(size.height / this.scenePixelSize.height)\n        } else {\n            this.pixelSize = Math.round(size.width / this.scenePixelSize.width)\n        }\n        this.pixelSize = Math.max(this.pixelSize, this.minPixelSize)\n        this.sceneOffset.x = (size.width - (this.pixelSize * this.scenePixelSize.width)) * 0.5\n        this.sceneOffset.y = (size.height - this.pixelSize * this.scenePixelSize.height) * 0.5\n    }\n\n    drawPixels(shape) {\n        if (!shape.visible) { return }\n        shape.pixels.forEach(pixel => {\n            shape.effects.forEach(effect => {\n                effect.render(pixel)\n            })\n            let offsetX = 0\n            let offsetY = 0\n            if (!this.isStatic) {\n                let px = ((this.pointer.x / this.canvas.width) - 0.5) * 2\n                let py = ((this.pointer.y / this.canvas.height) - 0.5) * 2\n                offsetX = px * shape.pointerOffset\n                offsetY = py * shape.pointerOffset\n            }\n            this.ctx.globalCompositeOperation = shape.blendMode\n            this.ctx.fillStyle = pixel.color.format()\n            this.ctx.globalAlpha = shape.opacity\n            let px = this.sceneOffset.x + (pixel.x + shape.x + offsetX) * this.pixelSize\n            let py = this.sceneOffset.y + (pixel.y + shape.y + offsetY) * this.pixelSize\n            px = Math.round(px / this.pixelSize) * this.pixelSize\n            py = Math.round(py / this.pixelSize) * this.pixelSize\n            this.ctx.fillRect(px, py, this.pixelSize, this.pixelSize)\n            this.ctx.globalAlpha = 1\n        })\n    }\n\n    drawImage(shape) {\n        if (!shape.visible) { return }\n        if (!shape.image) { return }\n        let image = shape.image\n        this.ctx.imageSmoothingEnabled = false\n        let offsetX = 0\n        let offsetY = 0\n        if (!this.isStatic) {\n            let px = ((this.pointer.x / this.canvas.width) - 0.5) * 2\n            let py = ((this.pointer.y / this.canvas.height) - 0.5) * 2\n            offsetX = px * shape.pointerOffset\n            offsetY = py * shape.pointerOffset\n        }\n        this.ctx.globalCompositeOperation = shape.blendMode\n        this.ctx.globalAlpha = shape.opacity\n        let px = this.sceneOffset.x + (shape.x + offsetX) * this.pixelSize - (image.width * this.pixelSize) * 0.5\n        let py = this.sceneOffset.y + (shape.y + offsetY) * this.pixelSize - (image.height * this.pixelSize) * 0.5\n        px = Math.round(px / this.pixelSize) * this.pixelSize\n        py = Math.round(py / this.pixelSize) * this.pixelSize\n        this.ctx.drawImage(image, 0, 0, image.width, image.height, px, py, image.width * this.pixelSize, image.height * this.pixelSize);\n    }\n}\n\nexport default Scene","import Events from \"./Events.js\"\nimport Color from \"./Color.js\"\n\nclass Shape {\n    constructor(object) {\n        this.visible = true\n        this.opacity = 1\n        this.blendMode = \"\"\n        this.pixels = []\n        this.effects = []\n        this.isReady = false\n        this.events = new Events()\n        if (object) {\n            this.parse(object)\n        }\n    }\n\n    addEffect(effect) {\n        this.effects.push(effect)\n    }\n\n    addEffects(effects) {\n        effects.forEach(effect => {\n            this.effects.push(effect)\n        })\n    }\n\n    parse(object) {\n        if (object.pixels) {\n            this.parseWithPixels(object)\n        } else if (object.image) {\n            this.parseWithImage(object)\n        }\n    }\n\n    parseWithPixels(object) {\n        this.rawObject = object\n        let boundry = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }\n        object.pixels.forEach(pixel => {\n            boundry.max.x = Math.max(boundry.max.x, pixel.x)\n            boundry.max.y = Math.max(boundry.max.y, pixel.y)\n            boundry.min.x = Math.min(boundry.min.x, pixel.x)\n            boundry.min.y = Math.min(boundry.min.y, pixel.y)\n        })\n        let center = {\n            x: Math.floor((boundry.max.x - boundry.min.x) * 0.5),\n            y: Math.floor((boundry.max.y - boundry.min.y) * 0.5),\n        }\n        let pixels = []\n        object.pixels.forEach(pixelData => {\n            let px = pixelData.x - center.x\n            let py = pixelData.y - center.y\n            let color\n            if (pixelData.color instanceof Color) {\n                color = pixelData.color\n            } else {\n                color = Color.fromHex(pixelData.color)\n            }\n            if (object.ignoreTransparentPixels && color.a == 0) {\n                return\n            }\n            let pixel = {\n                x: px,\n                y: py,\n                color: color\n            }\n            pixels.push(pixel)\n        })\n\n        this.boundry = boundry\n        this.pixels = pixels\n        this.pointerOffset = object.pointerOffset\n        this.x = center.x\n        this.y = center.y\n        this.isReady = true\n        this.events.fire(\"shapeIsReady\", this)\n    }\n\n    parseWithImage(object) {\n        loadImage(object.image, (image) => {\n            if (object.pixelated) {\n                object.pixels = parseImagePixels(\n                    image\n                )\n                this.parseWithPixels(object)\n                return\n            }\n            this.image = image\n            this.boundry = { min: { x: 0, y: 0 }, max: { x: image.width, y: image.height } }\n            this.pointerOffset = object.pointerOffset\n            this.x = 0\n            this.y = 0\n            this.isReady = true\n            this.events.fire(\"shapeIsReady\", this)\n        })\n    }\n}\n\nlet parseImagePixels = (image) => {\n    let canvas = document.createElement(\"canvas\")\n    let ctx = canvas.getContext(\"2d\")\n    ctx.drawImage(image, 0, 0)\n    let width = image.width\n    let height = image.height\n    let imageData = ctx.getImageData(0, 0, width, height)\n    let rgba = imageData.data\n    let pixels = []\n    for (var i = 0; i < width; i += 1) {\n        for (var j = 0; j < height; j += 1) {\n            let p = (j * width + i) * 4\n            let r = rgba[p]\n            let g = rgba[p + 1]\n            let b = rgba[p + 2]\n            let a = rgba[p + 3]\n            pixels.push({\n                x: i,\n                y: j,\n                color: Color.fromRGBA(r, g, b, a)\n            })\n        }\n    }\n    return pixels\n}\n\nlet loadImage = (src, completion) => {\n    let image = new Image()\n    image.onload = () => {\n        completion(image)\n    }\n    image.src = src\n}\n\nexport default Shape","let def = (configItem, defaultValue) => {\n    if (configItem) {\n        return configItem\n    }\n    return defaultValue\n}\n\nconst Utils = {def}\nexport default Utils","import Utils from \"../core/Utils.js\"\nconst def = Utils.def\n\nclass PixelColorChange {\n    constructor(shape, config) {\n        this.shape = shape\n        this.smoothness = def(config.smoothness, 0.1)\n\n        if (shape.isReady) {\n            this.configure(shape)\n        } else {\n            shape.events.addListener(\"shapeIsReady\", this, (shape) => {\n                this.configure(shape)\n            })\n        }\n    }\n\n    configure(shape) {\n        shape.pixels.forEach(pixel => {\n            pixel.colorChange = {\n                originalColor: pixel.color.clone(),\n                targetColor: pixel.color.clone()\n            }\n        })\n    }\n\n    render(pixel) {\n        if (!pixel.colorChange) { return }\n        let targetColor = pixel.colorChange.targetColor\n        pixel.color.r += Math.floor((targetColor.r - pixel.color.r) * this.smoothness)\n        pixel.color.g += Math.floor((targetColor.g - pixel.color.g) * this.smoothness)\n        pixel.color.b += Math.floor((targetColor.b - pixel.color.b) * this.smoothness)\n        pixel.color.a += Math.floor((targetColor.a - pixel.color.a) * this.smoothness)\n    }\n}\n\nexport default PixelColorChange","import Utils from \"../core/Utils.js\"\nconst def = Utils.def\n\nclass PixelDistort {\n    constructor(shape, configProvider) {\n        this.shape = shape\n        this.enabled = false\n        this.configProvider = configProvider\n\n        if (shape.isReady) {\n            this.configure(shape)\n        } else {\n            shape.events.addListener(\"shapeIsReady\", this, (shape) => {\n                this.configure(shape)\n            })\n        }\n    }\n\n    configure(shape) {\n        shape.pixels.forEach(pixel => {\n            let config = this.configProvider(pixel)\n            pixel.distort = {\n                radius: def(config.radius, 10),\n                speed: def(config.speed, 0.01),\n                smoothness: def(config.smoothness, 0.1),\n                tick: def(config.tick, Math.random() * Math.PI * 2),\n                ox: pixel.x,\n                oy: pixel.y,\n            }\n        })\n    }\n\n    render(pixel) {\n        let distort = pixel.distort\n        if (!distort) { return }\n        if (this.enabled) {\n            let px = Math.sin(distort.tick) * distort.radius\n            let py = Math.cos(distort.tick) * distort.radius\n            pixel.x += (px - pixel.x) * distort.smoothness\n            pixel.y += (py - pixel.y) * distort.smoothness\n        } else {\n            pixel.x += (pixel.distort.ox - pixel.x) * distort.smoothness\n            pixel.y += (pixel.distort.oy - pixel.y) * distort.smoothness\n        }\n        distort.tick += distort.speed\n    }\n}\n\nexport default PixelDistort","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Color from \"./core/Color.js\"\nimport Events from \"./core/Events.js\"\nimport Scene from \"./core/Scene.js\"\nimport Shape from \"./core/Shape.js\"\nimport Utils from \"./core/Utils.js\"\nimport PixelColorChange from \"./effects/PixelColorChange.js\"\nimport PixelDistort from \"./effects/PixelDistort.js\"\n\nconst Pixi = {Color, Events, Scene, Shape, Utils, PixelColorChange, PixelDistort}\n\nexport default Pixi"],"names":[],"sourceRoot":""}